// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.9.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "./extensions/IEscrowToken.sol";

contract EscrowNFT is AccessControlEnumerable,ERC721Burnable{
    using Counters for Counters.Counter;
    string private constant URI_PREFIX = "data:text/json;base64,";
    //{"description":"Eartha token escrow NFT.","external_url":"https://app.eartha.org/3","image":"ipfs://","name":"Escrow NFT","attributes":[{"trait_type":"Base","value":"Starfish"}]}
    string private constant URI_JSON_1 = '{"description":"Eartha token escrow NFT.","external_url":"https://app.eartha.org/';
    string private constant URI_JSON_2 = '","image":"ipfs://QmSJvEfmV5vdRoUkaqh3dZ6Yu6Pk9bpvRYqruB68iwD7iJ","name":"EscrowNFT","attributes":[';
    string private constant URI_JSON_ARRAY_1 = '{"trait_type":"';
    string private constant URI_JSON_ARRAY_2 = '","value":"';
    string private constant URI_JSON_ARRAY_3 = '"}';
    string private constant URI_JSON_END = ']}';

    bytes constant private base64stdchars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    bytes constant private base64urlchars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant URI_SETTER_ROLE = keccak256("URI_SETTER_ROLE");


    mapping(uint => uint) public toEscrowId;
    Counters.Counter private _tokenIdTracker = Counters.Counter(1);
    address public earthaTokenAddress;
    bool public initializedEarthaTokenAddress = false;

    constructor(
        string memory name_,
        string memory symbol_
    )
    AccessControlEnumerable()
    ERC721(name_,symbol_)
    {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(URI_SETTER_ROLE, _msgSender());
    }

    function initializeEarthaTokenAddress(address token)external virtual{
        require(!initializedEarthaTokenAddress,"already initialized");
        earthaTokenAddress = token;
        initializedEarthaTokenAddress = true;
    }

    modifier minterOnly(){
        require(hasRole(MINTER_ROLE, _msgSender()),"must have minter role to mint");
        _;
    }
    modifier uriSetterOnly(){
        require(hasRole(URI_SETTER_ROLE, _msgSender()),"must have uri setter role to uri set");
        _;
    }

    function mint(address to, uint escrowId) minterOnly() external virtual minterOnly() returns(uint){
        uint tokenId = _tokenIdTracker.current();
        _mint(to, tokenId);
        _tokenIdTracker.increment();
        toEscrowId[tokenId]=escrowId;
        return tokenId;
    }

    /**
    * @dev See {IERC165-supportsInterface}.
    */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721,AccessControlEnumerable) returns (bool) {
        return interfaceId == type(IAccessControlEnumerable).interfaceId
            || interfaceId == type(IERC721).interfaceId
            || super.supportsInterface(interfaceId);
    }

    /**
    * @dev See {IERC721Metadata-tokenURI}.
    */
    /*
    {
        "description": "Friendly OpenSea Creature that enjoys long swims in the ocean.",
        "external_url": "https://openseacreatures.io/3",
        "image": "https://storage.googleapis.com/opensea-prod.appspot.com/puffs/3.png",
        "name": "Dave Starbelly",
        "attributes": [ ... ],
    }
    */
    function tokenURI(uint256 tokenId) public view virtual override(ERC721) returns (string memory)  {
        string[10] memory json;
        {
            uint escrowId = toEscrowId[tokenId];
            json[0]=string(
                abi.encodePacked(
                    URI_JSON_1,
                    uint2str(escrowId),
                    URI_JSON_2
                )
            );
        }
        {
            IEscrowToken token = IEscrowToken(earthaTokenAddress);
            uint escrowId = toEscrowId[tokenId];
            IEscrowToken.EscrowDetail memory escrow = token.getEscrowDetail(escrowId);
            json[1]=_getAttributes("currencyValue",uint2str(escrow.currencyValue));
        }
        {
            IEscrowToken token = IEscrowToken(earthaTokenAddress);
            uint escrowId = toEscrowId[tokenId];
            IEscrowToken.EscrowDetail memory escrow = token.getEscrowDetail(escrowId);
            json[2]=_getAttributes("value",uint2str(escrow.value));
        }
        {
            IEscrowToken token = IEscrowToken(earthaTokenAddress);
            uint escrowId = toEscrowId[tokenId];
            IEscrowToken.EscrowDetail memory escrow = token.getEscrowDetail(escrowId);
            json[3]=_getAttributes("currencyCode",escrow.currencyCode);
        }
        {
            IEscrowToken token = IEscrowToken(earthaTokenAddress);
            uint escrowId = toEscrowId[tokenId];
            IEscrowToken.EscrowDetail memory escrow = token.getEscrowDetail(escrowId);
            json[4]=_getAttributes("hedgeRate",uint2str(uint(escrow.hedgeRate)));
        }
        {
            IEscrowToken token = IEscrowToken(earthaTokenAddress);
            uint escrowId = toEscrowId[tokenId];
            IEscrowToken.EscrowDetail memory escrow = token.getEscrowDetail(escrowId);
            json[5]=_getAttributes("status",uint2str(uint(escrow.status)));
        }
        {
            IEscrowToken token = IEscrowToken(earthaTokenAddress);
            uint escrowId = toEscrowId[tokenId];
            IEscrowToken.EscrowDetail memory escrow = token.getEscrowDetail(escrowId);
            json[6]=_getAttributes("canRefund",escrow.canRefund?"true":"false");
        }
        {
            IEscrowToken token = IEscrowToken(earthaTokenAddress);
            uint escrowId = toEscrowId[tokenId];
            IEscrowToken.EscrowDetail memory escrow = token.getEscrowDetail(escrowId);
            json[7]=_getAttributes("terminatedTime",uint2str(escrow.terminatedTime));
        }
        {
            IEscrowToken token = IEscrowToken(earthaTokenAddress);
            uint escrowId = toEscrowId[tokenId];
            IEscrowToken.EscrowDetail memory escrow = token.getEscrowDetail(escrowId);
            json[8]=string(
                abi.encodePacked(
                    URI_JSON_ARRAY_1,
                    "type",
                    URI_JSON_ARRAY_2,
                    escrow.createrTokenId == tokenId?"creater":"recipient",
                    URI_JSON_ARRAY_3
                )
            );
        }
        {
            json[9]=URI_JSON_END;
        }
        string memory jsonStr = string(
            abi.encodePacked(
                json[0],
                json[1],
                json[2],
                json[3],
                json[4],
                json[5],
                json[7],
                json[8],
                json[9]
            )
        );
        return string(
            abi.encodePacked(
                URI_PREFIX,
                encode(jsonStr)
            )
        );
    }
    function _getAttributes(string memory key,string memory value)internal pure returns(string memory){
            return string(
                abi.encodePacked(
                    URI_JSON_ARRAY_1,
                    key,
                    URI_JSON_ARRAY_2,
                    value,
                    URI_JSON_ARRAY_3,
                    ","
                )
            );
    }
    function uint2str(uint _i) internal pure returns (string memory) {
        if (_i == 0) {
            return "0";
        }
        uint j = _i;
        uint len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len;
        while (_i != 0) {
            k = k-1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }


    function encode(string memory _str) internal pure returns (string memory) {

        bytes memory _bs = bytes(_str);
        uint256 rem = _bs.length % 3;

        uint256 res_length = (_bs.length + 2) / 3 * 4 - ((3 - rem) % 3);
        bytes memory res = new bytes(res_length);

        uint256 i = 0;
        uint256 j = 0;

        for (; i + 3 <= _bs.length; i += 3) {
            (res[j], res[j+1], res[j+2], res[j+3]) = encode3(
                uint8(_bs[i]),
                uint8(_bs[i+1]),
                uint8(_bs[i+2])
            );

            j += 4;
        }

        if (rem != 0) {
            uint8 la0 = uint8(_bs[_bs.length - rem]);
            uint8 la1 = 0;

            if (rem == 2) {
                la1 = uint8(_bs[_bs.length - 1]);
            }

            (bytes1 b0, bytes1 b1, bytes1 b2,) = encode3(la0, la1, 0);
            res[j] = b0;
            res[j+1] = b1;
            if (rem == 2) {
                res[j+2] = b2;
            }
        }

        return string(res);
    }

    function encode3(uint256 a0, uint256 a1, uint256 a2)
        private
        pure
        returns (bytes1 b0, bytes1 b1, bytes1 b2, bytes1 b3)
    {

        uint256 n = (a0 << 16) | (a1 << 8) | a2;

        uint256 c0 = (n >> 18) & 63;
        uint256 c1 = (n >> 12) & 63;
        uint256 c2 = (n >>  6) & 63;
        uint256 c3 = (n      ) & 63;

        b0 = base64urlchars[c0];
        b1 = base64urlchars[c1];
        b2 = base64urlchars[c2];
        b3 = base64urlchars[c3];
    }

    /*
    {
        "name": "OpenSea Creatures",
        "description": "OpenSea Creatures are adorable aquatic beings primarily for demonstrating what can be done using the OpenSea platform. Adopt one today to try out all the OpenSea buying, selling, and bidding feature set.",
        "image": "https://openseacreatures.io/image.png",
        "external_link": "https://openseacreatures.io",
        "seller_fee_basis_points": 100, # Indicates a 1% seller fee.
        "fee_recipient": "0xA97F337c39cccE66adfeCB2BF99C1DdC54C2D721" # Where seller fees will be paid to.
    }
    */
    function contractURI() public pure returns (string memory) {
        return "ipfs://QmeYoKfpqF8iAzwLJhxpxrtEuBFXDqPsTD2YREMiSA5hge";
    }
}
